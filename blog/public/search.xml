<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS异常处理及signal信号]]></title>
      <url>jokewang.top/2017/08/10/iOS%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%8F%8Asingal%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<h1 id="系统crash"><a href="#系统crash" class="headerlink" title="系统crash"></a>系统crash</h1><p>不讲2333 什么时候想起来再填充</p>
<h1 id="singal信号"><a href="#singal信号" class="headerlink" title="singal信号"></a>singal信号</h1><blockquote>
<p>软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。</p>
</blockquote>
<p>下面是一些信号说明，添加的备注是我的理解，未添加的表示没遇到过</p>
<h2 id="1-SIGHUP"><a href="#1-SIGHUP" class="headerlink" title="1) SIGHUP"></a>1) SIGHUP</h2><blockquote>
<p>本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。<br>登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进 程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录， wget也 能继续下载。<br>此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</p>
</blockquote>
<h2 id="2-SIGINT"><a href="#2-SIGINT" class="headerlink" title="2) SIGINT"></a>2) SIGINT</h2><blockquote>
<p>程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。</p>
</blockquote>
<p>貌似手机上发不出这个信号。</p>
<a id="more"></a>
<h2 id="3-SIGQUIT"><a href="#3-SIGQUIT" class="headerlink" title="3) SIGQUIT"></a>3) SIGQUIT</h2><blockquote>
<p>和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。</p>
</blockquote>
<p>貌似也收不到</p>
<h2 id="4-SIGILL"><a href="#4-SIGILL" class="headerlink" title="4) SIGILL"></a>4) SIGILL</h2><blockquote>
<p>执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</p>
</blockquote>
<p>不管在任何情况下得杀死进程的信号,iOS 禁止app内kill进程，不用操心</p>
<h2 id="5-SIGTRAP"><a href="#5-SIGTRAP" class="headerlink" title="5) SIGTRAP"></a>5) SIGTRAP</h2><blockquote>
<p>由断点指令或其它trap指令产生. 由debugger使用。</p>
</blockquote>
<p>release环境一定不可能是断点，所以就是trap指令了，比如调用下面方法就会发出这个信号</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSException</span></div><div class="line">+ (<span class="keyword">void</span>)raise:(<span class="built_in">NSExceptionName</span>)name format:(<span class="built_in">NSString</span> *)format, ... <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">+ (<span class="keyword">void</span>)raise:(<span class="built_in">NSExceptionName</span>)name format:(<span class="built_in">NSString</span> *)format arguments:(va_list)argList <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">2</span>,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<h2 id="6-SIGABRT"><a href="#6-SIGABRT" class="headerlink" title="6) SIGABRT"></a>6) SIGABRT</h2><blockquote>
<p>调用abort函数生成的信号。</p>
</blockquote>
<p>iOS中一般是手动调用或者数组越界。FMDB中有这个函数</p>
<h2 id="7-SIGBUS"><a href="#7-SIGBUS" class="headerlink" title="7) SIGBUS"></a>7) SIGBUS</h2><blockquote>
<p>非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</p>
</blockquote>
<p>比如多线程读写一个对象，代理用assign<br>解决此类问题需要有一定的汇编知识,<a href="http://www.jianshu.com/p/544464a5e630" target="_blank" rel="external">iOS汇编教程：理解ARM</a>介绍了常用的汇编代码。</p>
<p>另外<a href="https://my.oschina.net/bugly/blog/919482" target="_blank" rel="external">教你 Debug 的正确姿势——记一次 CoreMotion 的 Crash</a>手Q一个小哥写的关于SIGBUS的文章非常棒。对于5，7，11这些都可以用这篇文章中提供的方法来找到</p>
<h2 id="8-SIGFPE"><a href="#8-SIGFPE" class="headerlink" title="8) SIGFPE"></a>8) SIGFPE</h2><blockquote>
<p>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</p>
</blockquote>
<h2 id="9-SIGKILL"><a href="#9-SIGKILL" class="headerlink" title="9) SIGKILL"></a>9) SIGKILL</h2><blockquote>
<p>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。</p>
</blockquote>
<p>用户或者系统删除后台进程会发送此信号，需要注意系统杀死后台的进程的情况并非只有内存使用过多，CPU占用大也会被杀死</p>
<h2 id="10-SIGUSR1"><a href="#10-SIGUSR1" class="headerlink" title="10) SIGUSR1"></a>10) SIGUSR1</h2><blockquote>
<p>没在POSIX.1中列出，而在SUSv2列出 同7 SIGBUS</p>
</blockquote>
<h2 id="11-SIGSEGV"><a href="#11-SIGSEGV" class="headerlink" title="11) SIGSEGV"></a>11) SIGSEGV</h2><blockquote>
<p>试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.</p>
</blockquote>
<p>比如空指针，未初始化指针，栈溢出等；</p>
<h2 id="12-SIGUSR2"><a href="#12-SIGUSR2" class="headerlink" title="12) SIGUSR2"></a>12) SIGUSR2</h2><blockquote>
<p>没在POSIX.1中列出，而在SUSv2列出 无效的系统调用 (SVID) 同SIGSYS</p>
</blockquote>
<h2 id="13-SIGPIPE"><a href="#13-SIGPIPE" class="headerlink" title="13) SIGPIPE"></a>13) SIGPIPE</h2><blockquote>
<p>管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</p>
</blockquote>
<h2 id="14-SIGALRM"><a href="#14-SIGALRM" class="headerlink" title="14) SIGALRM"></a>14) SIGALRM</h2><blockquote>
<p>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.</p>
</blockquote>
<p>剩下的基本都不会遇到</p>
<h1 id="Exception-Code"><a href="#Exception-Code" class="headerlink" title="Exception Code"></a>Exception Code</h1><p>有一些值代表固定的意思比如下面这些</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x8badf00d</td>
<td>在启动、终⽌止应⽤用或响应系统事件花费过⻓长时间,意为“ate bad food”。    <br> <br>对于此类Crash，我们应该去审视自己App初始化时做的事情是否正确，是否在主线程请求了网络，或者其他耗时的事情卡住了正常初始化流程。通常系统允许一个App从启动到可以相应用户事件的时间最多为5S，如果超过了5S，App就会被系统终止掉。在Launch，resume，suspend，quit时都会有相应的时间要求。在Highlight Thread里面我们可以看到被终止时调用到的位置，xxxAppDelegate加上行<br></td>
</tr>
<tr>
<td>0xdeadfa11</td>
<td>⽤用户强制退出,意为“dead fall”。(系统⽆无响应时,⽤用户按电源开关和HOME)<br><br>这个强制退出跟我们平时所说的kill掉后台任务操作还不太一样，通常在程序bug造成系统无法响应时可以采用长按电源键，当屏幕出现关机确认画面时按下Home键即可关闭当前程序。<br></td>
</tr>
<tr>
<td>0xbaaaaaad</td>
<td>⽤用户按住Home键和⾳音量键,获取当前内存状态,不代表崩溃<br></td>
</tr>
<tr>
<td>0xbad22222</td>
<td>VoIP应⽤用因为恢复得太频繁导致crash<br></td>
</tr>
<tr>
<td>0xc00010ff</td>
<td>因为太烫了被干掉,意为“cool off”<br></td>
</tr>
<tr>
<td>0xdead10cc</td>
<td>因为在后台时仍然占据系统资源(⽐比如通讯录)被干掉,意为“dead lock”<br></td>
</tr>
</tbody>
</table>
<p>参考文档：</p>
<ul>
<li><a href="http://www.iosxxx.com/blog/2015-08-29-iosyi-chang-bu-huo.html" target="_blank" rel="external">iOS异常捕获</a></li>
<li><a href="http://www.cocoachina.com/ios/20150122/10991.html" target="_blank" rel="external">iOS Crash文件的解析</a></li>
<li><a href="http://www.jianshu.com/p/5c0e1768ba54" target="_blank" rel="external">iOS中常见的crash信号处理</a></li>
<li><a href="http://satanwoo.github.io/2017/01/07/DispatchGroupCrash/" target="_blank" rel="external">hiOS疑难问题排查之深入探究dispatch_group crash</a></li>
<li><a href="https://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/" target="_blank" rel="external">浅谈一种解决多线程野指针的新思路</a></li>
<li><a href="https://dev.qq.com/topic/59150e72142eee2b6b97359a" target="_blank" rel="external">手把手教你如何分析 iOS 系统栈 crash</a></li>
<li><a href="https://people.cs.pitt.edu/~alanjawi/cs449/code/shell/UnixSignals.htm" target="_blank" rel="external">Unix Signals</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode自定义waring]]></title>
      <url>jokewang.top/2017/05/26/Xcode%E8%87%AA%E5%AE%9A%E4%B9%89waring/</url>
      <content type="html"><![CDATA[<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/xcode%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC.png" alt="添加方法"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">KEYWORDS=&quot;\/\/TODO|\/\/FIXME|\/\/\?\?\?:|\/\/\!\!\!:&quot;</div><div class="line">	find &quot;$&#123;SRCROOT&#125;&quot; \( -name &quot;*.h&quot; -or -name &quot;*.m&quot; -or -name &quot;*.swift&quot; \) -print0 | \</div><div class="line">	xargs -0 egrep --with-filename --line-number --only-matching &quot;($KEYWORDS).*\$&quot; | \</div><div class="line">	perl -p -e &quot;s/($KEYWORDS)/ warning: \$1/&quot;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[京阿尼之诗]]></title>
      <url>jokewang.top/2017/05/02/%E4%BA%AC%E9%98%BF%E5%B0%BC%E4%B9%8B%E8%AF%97/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一口冰菓一夏天，一首轻音一时间<br>境界彼方几何远？春夏冬来泪又迁<br>青春无悔中二恋，幸运之星伴身边<br>喜悦岂无无彩限？欢快畅游游乐园<br>最爱日常打闹喜，小林玉子乐更添<br>泳池中来绽光彩，永恒中去赏花园<br>爱之物语声之形，全金校园乐趣全<br>身在春日何忧郁？ 吹响号角向明天</p>
</blockquote>
<p>真好～</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS8中那些我可能用到的API]]></title>
      <url>jokewang.top/2017/02/16/iOS8%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%88%91%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84API/</url>
      <content type="html"><![CDATA[<p>公司新的项目是以iOS8为最低支持版本的，所以写一份备忘录记录一下那些iOS8中更好用且常用的API</p>
<pre><code>let yosemite = NSOperatingSystemVersion(majorVersion: 10, minorVersion: 10, patchVersion: 0)
</code></pre><p>NSProcessInfo().isOperatingSystemAtLeastVersion(yosemite) // false<br>新的判断版本的方法</p>
<pre><code>localizedCaseInsensitiveContainsString
</code></pre><p>不区分大小写匹配字符串是否包含相比以前rangOfstring要简单</p>
<pre><code>wkwebview
</code></pre><p>iOS8可以考虑开始使用wkwebView来代替UIWebview</p>
<pre><code>NSQualityOfService
</code></pre><blockquote>
<p>线程这个概念已经在苹果的框架中被系统性的忽略。这对于开发者而言是件好事。<br>沿着这个趋势，NSOperation中新的qualityOfService的属性取代了原来的threadPriority。通过它可以推迟那些不重要的任务，从而让用户体验更加流畅。<br>NSQualityOfService枚举定义了以下值：<br>UserInteractive：和图形处理相关的任务，比如滚动和动画。<br>UserInitiated：用户请求的任务，但是不需要精确到毫秒级。例如，如果用户请求打开电子邮件App来查看邮件。<br>Utility：周期性的用户请求任务。比如，电子邮件App可能被设置成每五分钟自动检查新邮件。但是在系统资源极度匮乏的时候，将这个周期性的任务推迟几分钟也没有大碍。<br>Background：后台任务，用户可能并不会察觉对这些任务。比如，电子邮件App对邮件进行引索以方便搜索。<br>Quality of Service将在iOS 8和OS X Yosemite中广泛的应用，所以留意所有能利用它们的机会。</p>
</blockquote>
<pre><code>LocalAuthentication
</code></pre><p>TouchID的类，指纹解锁还是相当方便的 配合keychian 一个指纹处处登陆。</p>
<p><a href="https://developer.apple.com/library/content/releasenotes/General/iOS80APIDiffs/index.html#//apple_ref/doc/uid/TP40014455" target="_blank" rel="external">iOS7到iOS8变化的API</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[控制器push过程中的生命周期]]></title>
      <url>jokewang.top/2016/12/05/%E6%8E%A7%E5%88%B6%E5%99%A8push%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h1 id="A-展现的时候"><a href="#A-展现的时候" class="headerlink" title="A 展现的时候"></a>A 展现的时候</h1><ul>
<li>A viewDidLoad</li>
<li>A viewWillAppear</li>
<li>A viewWillLayoutSubviews</li>
<li>A viewDidLayoutSubviews</li>
<li>A viewDidAppear</li>
</ul>
<h1 id="A-push-到-B-的时候"><a href="#A-push-到-B-的时候" class="headerlink" title="A push 到 B 的时候"></a>A push 到 B 的时候</h1><ul>
<li>A viewWillDisappear</li>
<li>B viewDidLoad</li>
<li>B viewWillAppear</li>
<li>B viewWillLayoutSubviews</li>
<li>B viewDidLayoutSubviews</li>
<li>A viewDidDisappear</li>
<li>B viewDidAppear</li>
</ul>
<h1 id="B-pop-回-A-的时候"><a href="#B-pop-回-A-的时候" class="headerlink" title="B pop 回 A 的时候"></a>B pop 回 A 的时候</h1><ul>
<li>B viewWillDisappear</li>
<li>A viewWillAppear</li>
<li>B viewDidDisappear</li>
<li>A viewDidAppear</li>
<li>B dealloc</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSDataDetector]]></title>
      <url>jokewang.top/2016/11/29/NSData%E2%80%8BDetector/</url>
      <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>NSDataDetector 是 NSRegularExpression 的子类，而不只是一个 ICU 的模式匹配，它可以检测半结构化的信息：日期，地址，链接，电话号码和交通信息。</p>
<p>NSDataDetector 对象用一个需要检查的信息的位掩码类型来初始化，然后传入一个需要匹配的字符串。像 NSRegularExpression 一样，在一个字符串中找到的每个匹配是用 NSTextCheckingResult 来表示的，它有诸如字符范围和匹配类型的详细信息。然而，NSDataDetector 的特定类型也可以包含元数据，如地址或日期组件。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSDataDetector</span> *detector = [<span class="built_in">NSDataDetector</span> dataDetectorWithTypes:<span class="built_in">NSTextCheckingTypeAddress</span></div><div class="line">                                                        | <span class="built_in">NSTextCheckingTypePhoneNumber</span></div><div class="line">                                                           error:&amp;error];</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *string = <span class="string">@"123 Main St. / (555) 555-5555"</span>;</div><div class="line">[detector enumerateMatchesInString:string</div><div class="line">                           options:kNilOptions</div><div class="line">                             range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [string length])</div><div class="line">                        usingBlock:</div><div class="line">^(<span class="built_in">NSTextCheckingResult</span> *result, <span class="built_in">NSMatchingFlags</span> flags, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Match: %@"</span>, result);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>当初始化 NSDataDetector 的时候，确保只指定你感兴趣的类型。每当增加一个需要检查的类型，随着而来的是不小的性能损失为代价。</p>
</blockquote>
<a id="more"></a>
<h1 id="数据检测器匹配类型"><a href="#数据检测器匹配类型" class="headerlink" title="数据检测器匹配类型"></a>数据检测器匹配类型</h1><p>下面是 NSDataDetector 的各种 NSTextCheckingTypes 匹配，及其相关属性表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSTextCheckingTypeDate</td>
<td><ul><li> dated </li> <li> uration </li> <li> timeZone </li> </ul></td>
</tr>
<tr>
<td>NSTextCheckingTypeAddress</td>
<td><ul><li> addressComponents* </li> <li> NSTextCheckingNameKey </li> <li> NSTextCheckingJobTitleKey </li> <li> NSTextCheckingOrganizationKey </li> <li> NSTextCheckingStreetKey </li> <li> NSTextCheckingCityKey </li> <li> NSTextCheckingStateKey </li> <li> NSTextCheckingZIPKey </li> <li> NSTextCheckingCountryKey </li> <li> NSTextCheckingPhoneKey </li></ul> </td>
</tr>
<tr>
<td>NSTextCheckingTypeLink</td>
<td><ul><li> url </li></ul></td>
</tr>
<tr>
<td>NSTextCheckingTypePhoneNumber</td>
<td><ul><li> phoneNumber </li></ul></td>
</tr>
<tr>
<td>NSTextCheckingTypeTransitInformation</td>
<td><ul><li> components* </li> <li> NSTextCheckingAirlineKey </li> <li> NSTextCheckingFlightKey </li></ul></td>
</tr>
</tbody>
</table>
<p>*号  NSDictionary properties have values at defined keys.</p>
<h1 id="在-iOS-上做数据检测"><a href="#在-iOS-上做数据检测" class="headerlink" title="在 iOS 上做数据检测"></a>在 iOS 上做数据检测</h1><p>有点混乱的是，iOS 也定义了 UIDataDetectorTypes。这些位掩码的值可以设置成一个 UITextView 的 dataDetectorTypes，来自动检测显示的文本。</p>
<p>UIDataDetectorTypes 和 NSTextCheckingTypes 相同的那些枚举常量其实是不同的（如 UIDataDetectorTypePhoneNumber 和 NSTextCheckingTypePhoneNumber），他们的整数值并不一样，而且一个中的所有值也并不能在另外一个里面都能找到。可以用以下方法把 UIDataDetectorTypes 转换为 NSTextCheckingTypes：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSTextCheckingType</span> <span class="built_in">NSTextCheckingTypesFromUIDataDetectorTypes</span>(<span class="built_in">UIDataDetectorTypes</span> dataDetectorType) &#123;</div><div class="line">    <span class="built_in">NSTextCheckingType</span> textCheckingType = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (dataDetectorType &amp; <span class="built_in">UIDataDetectorTypeAddress</span>) &#123;</div><div class="line">        textCheckingType |= <span class="built_in">NSTextCheckingTypeAddress</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dataDetectorType &amp; <span class="built_in">UIDataDetectorTypeCalendarEvent</span>) &#123;</div><div class="line">        textCheckingType |= <span class="built_in">NSTextCheckingTypeDate</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dataDetectorType &amp; <span class="built_in">UIDataDetectorTypeLink</span>) &#123;</div><div class="line">        textCheckingType |= <span class="built_in">NSTextCheckingTypeLink</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dataDetectorType &amp; <span class="built_in">UIDataDetectorTypePhoneNumber</span>) &#123;</div><div class="line">        textCheckingType |= <span class="built_in">NSTextCheckingTypePhoneNumber</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> textCheckingType;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：<a href="http://nshipster.com/nsdatadetector/" target="_blank" rel="external">http://nshipster.com/nsdatadetector/</a></p>
<p>UILabel的使用  <a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="external">TTTAttributedLabel</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[汇编基础知识]]></title>
      <url>jokewang.top/2016/11/16/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="Type-与-Value"><a href="#Type-与-Value" class="headerlink" title="Type 与 Value"></a>Type 与 Value</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int i = 123;</div><div class="line">char c = (char)i;</div></pre></td></tr></table></figure>
<p>这段代码声明了一个 int 类型的变量和一个 char 类型的变量，有初始化和类型强转过程，在 x86_64 架构下，这两行代码的汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">movl $123, -4(%rbp)</div><div class="line">movl -4(%rbp), %eax</div><div class="line">movb %al, %cl</div><div class="line">movb %cl, -5(%rbp)</div></pre></td></tr></table></figure>
<pre><code>movl $123, -4(%rbp)
</code></pre><p>move 指令就是简单的值拷贝，这条指令中出现的 movl 表示按低 32 位的长度来拷贝（也就是一个 int 的长度），与之相似的还有 8 位的 movb（char）、16 位的 movw (short)、64 位的 movq (long in 64) 等；$123 即字面常量值；-4(%rbp) 代表 base pointer - 栈基地址寄存器，偏移 4 字节的位置。</p>
<pre><code>movl -4(%rbp), %eax
</code></pre><p>将刚才 4 字节长度内存赋值给 %eax 寄存器，它是最常用的通用寄存器之一，名为 accumulator，在 64 位架构下，rax 表示这个寄存器的完全体，eax 表示它的低 32 位，ax 表示低 16 位，ah 表示第 8~16 位，al 表示最低的 8 位。这样抠门的设计一部分因为兼容历史的 32 架构，一方面也是为了更充分利用寄存器这个宝贵的资源： </p>
<p><img src="http://7xtel4.com1.z0.glb.clouddn.com/2016-08-13-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-07-27%20%E4%B8%8B%E5%8D%8810.51.59.png" alt=""></p>
<pre><code>movb %al, %cl
</code></pre><p>按 8 位长度 (char) 将 a 寄存器的最低 8 位移动到 c 寄存器（count register）的低 8 位。这一个指令就在做 int 到 char 的类型转换，把 123 存在寄存器的低 32 位上，再把寄存器的最低 8 位取出来，相当于把 00000000000000000000000001111011 截断成了 01111011。</p>
<pre><code>movb %cl, -5(%rbp)
</code></pre><p>最后，再把刚才的结果按 8 字节的长度拷贝到 %rbp 偏移 5 的位置，完成这个 char 类型栈变量的赋值</p>
<p>参考<a href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-1/" target="_blank" rel="external">孙源文章</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移动端直播技术选型]]></title>
      <url>jokewang.top/2016/11/15/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="自己做还是用SDK"><a href="#自己做还是用SDK" class="headerlink" title="自己做还是用SDK"></a>自己做还是用SDK</h1><p>先上个流程图<br><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E7%9B%B4%E6%92%AD%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h2 id="自己做"><a href="#自己做" class="headerlink" title="自己做"></a>自己做</h2><ul>
<li>优点：<br>就是高度自定义，相对便宜,为以后向流媒体发展铺垫技术</li>
<li>缺点：<br>需要各个端都要熟悉，复杂。</li>
</ul>
<h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><ul>
<li>优点：<br>现有API可以用，简单</li>
<li>缺点：<br>相对自己做费用要高，但是流量和存储费用两者都要掏</li>
</ul>
<a id="more"></a>
<p>对比了一下，还是SDK来的简单。</p>
<h1 id="各SDK平台对比"><a href="#各SDK平台对比" class="headerlink" title="各SDK平台对比"></a>各SDK平台对比</h1><table>
<thead>
<tr>
<th>名称</th>
<th>趣拍</th>
<th>百度云</th>
<th>网易云</th>
<th>阿里云</th>
<th>金山云</th>
<th>乐视云</th>
</tr>
</thead>
<tbody>
<tr>
<td>单价</td>
<td>10G以下免费，超过0.36元/GB</td>
<td>按流量算：<br>0.64元/GB <br>按每日峰值算:<br>1.8元/Mbps/天</td>
<td>按流量算：<br>1元/GB <br>按每日峰值算:<br>1.17元/Mbps/天</td>
<td>尚不明确</td>
<td>尚不明确</td>
<td>基础部分如图1<br>超出流量：0.49元/GB<br>超出转码时长720P/1080P：0.018元/分钟<br></td>
</tr>
<tr>
<td>500用户同时观看总时长60分钟</td>
<td>标清（480p）：<br> 46.35元 <br>高清（720p）: <br>79.10元</td>
<td>标清（480p）：<br> 82.56元(流量算) <br> 526.89元/天 <br>高清（720p）:<br>140.90元(流量算)<br>899.23元/天</td>
<td>标清（480p）：<br>129元(流量算) <br>342.48元/天 <br>高清（720p）: <br>220.17元(流量算) <br>584.5元/天</td>
<td>尚不明确</td>
<td>尚不明确</td>
<td></td>
</tr>
<tr>
<td>优点</td>
<td>用户少的时候按流量算最便宜</td>
<td>自定义设计较多</td>
<td>实现简单</td>
<td></td>
<td>技术成熟</td>
<td>技术成熟 </td>
</tr>
<tr>
<td>缺点</td>
<td>需要自建推流服务器，但提供SDK，UI不可自定义</td>
<td></td>
<td></td>
<td></td>
<td>文档复杂</td>
<td>文档复杂</td>
</tr>
</tbody>
</table>
<p>大部分 SDK提供商已经将主要功能做完整，百度云在自定义方面设计的比较多。网易云简单易接入。<br><br><br><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E7%9B%B4%E6%92%AD_%E4%B9%90%E8%A7%86%E5%9F%BA%E7%A1%80%E4%BB%B7%E6%A0%BC.png" alt="图 1 乐视视频云基础定价"></p>
<center><font color="Silver"> 图 1 乐视视频云基础定价</font></center>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[博客迁移]]></title>
      <url>jokewang.top/2016/11/11/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<h1 id="迁移原因"><a href="#迁移原因" class="headerlink" title="迁移原因"></a>迁移原因</h1><p>一直把博客托管在git上，但是上周突然CSS样式加载不了。就想自己搭个服务器。正好学一下服务器知识。再加上腾讯云各种打折。于是说干就干</p>
<h1 id="迁移过程"><a href="#迁移过程" class="headerlink" title="迁移过程"></a>迁移过程</h1><p>刚开始是用的centOS 搭的服务器，结果发现竟然是命令行，搞了几次实在搞不懂就换成了windows Server2012  讲真，windows做的真不错。腾讯的客服也给力。<br>然而。好多命令在windows上并没有，而GUI的方法又没有教程。。。。<br>我又再次麻烦了腾讯客服换成了centOS  23333😂<br>最后找了好几个博客。一直没弄好，而且基本上所有博客都一样。。。真是天下文章一大抄。<br> 最后看了<a href="http://www.hansoncoder.com/2016/03/02/VPS-building-Hexo/#VPS上安装配置Git" target="_blank" rel="external">这个</a>博客才把问题解决的，但是也出了一些问题。</p>
 <a id="more"></a>
<h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><ul>
<li>参考博客是通过网页把内容粘贴到文件中的，（公钥之类的），我竟然是手打，后来发现通过FTP 的方式可以可视化粘贴内容，特别方便。或者用本地SSH客户端，总之不要用腾讯网页版的SSH连接，不能粘贴很麻烦。</li>
<li>一定要注意权限问题，我最后所有都能好了，但是就是上传不上去。git一直提示没权限，看好是用哪个用户建立的</li>
<li>git仓库的权限写757会方便， 757是会有公共写入权限。 755只有用户有权限，上传的时候莫名其妙遇到问题。</li>
<li>博客用的centOS 6.X 的系统，我用的7.2 有的命令发生了变化，按提示的命令来就OK了，有的软件没有的话用 yum 安装一下就ok了。</li>
<li><code>[root /]# /etc/init.d/nginx start</code> 这个命令发生了大变化，7.2不再需要配置文件然后通过脚本启动了,参考<a href="https://my.oschina.net/liucao/blog/470344" target="_blank" rel="external">这篇文章</a></li>
<li>最后，如果git方法不行，或者git太麻烦的话，本地生成的public 目录，直接扔到Nginx 服务器目录就OK了，可视化操作还是很快的</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[孙源博客]]></title>
      <url>jokewang.top/2016/11/07/%E5%AD%99%E6%BA%90%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>以前看过源神的tableview高度自动布局库，<br>然后今天看到了源神的<a href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/" target="_blank" rel="external">重识 Objective-C Runtime - Smalltalk 与 C 的融合</a>和<a href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-1/" target="_blank" rel="external">重识 Objective-C Runtime - 看透 Type 与 Value</a>感觉发现了新大陆啊。<br>然后看了眼源神博客列表各种黑科技。<br>强烈推荐<a href="http://blog.sunnyxx.com/" target="_blank" rel="external">源神博客</a>。<br>虽然没人看我的博客2333。</p>
<blockquote class="blockquote-center">只有最充满智慧并严于律己的学徒才能够走上法师之路。</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Objective-C类成员变量深度剖析]]></title>
      <url>jokewang.top/2016/11/07/Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
      <content type="html"><![CDATA[<ul>
<li>Objective-C的 -&gt; 操作符不是C语言指针操作！</li>
<li>Objective-C对象不能简单对应于一个C struct，访问成员变量不等于访问C struct成员！</li>
</ul>
<p>参考<a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="external">这篇文章</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[xcode8更新出现的坑]]></title>
      <url>jokewang.top/2016/09/14/xcode8%E6%9B%B4%E6%96%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<h1 id="xcode8注释快捷键失效的问题"><a href="#xcode8注释快捷键失效的问题" class="headerlink" title="xcode8注释快捷键失效的问题"></a>xcode8注释快捷键失效的问题</h1><p>1、命令行里输入：</p>
<p>sudo /usr/libexec/xpccachectl</p>
<p>2、重启电脑</p>
<h1 id="xcode8插件失效问题"><a href="#xcode8插件失效问题" class="headerlink" title="xcode8插件失效问题"></a>xcode8插件失效问题</h1><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="update："><a href="#update：" class="headerlink" title="update："></a>update：</h3><p> <a href="https://github.com/inket/update_xcode_plugins" target="_blank" rel="external">这个命令更简单的样子</a></p>
<p> 去签名版本可能无限菊花闪退，解决办法<br> 系统偏好设置-安全性与隐私-隐私-通讯录  去掉xcode前面的勾<br> 然后把插件都拿出来，一个个添加排除闪退的插件。</p>
  <a id="more"></a>
<p>—————-以前的——————————– </p>
<ul>
<li>1.下载<a href="https://github.com/fpg1503/MakeXcodeGr8Again" target="_blank" rel="external">这个插件</a>导出 product（product-archive-选择最后一个）</li>
<li>2.退出 Xcode8，同时运行刚刚导出的 MakeXcodeGr8Again，将 Xcode8 拖入其中，等待一段时间(3~10分钟)。</li>
<li>3.等菊花转完后，应用程序文件夹下会生成一个 XcodeGr8 的应用，运行命令 sudo xcode-select -s /Applications/XcodeGr8.app/Contents/Developer 将 Xcode 开发路径指向刚生成的 XcodeGr8。</li>
<li>4.命令行里输入：<br>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add <code>defaults read /Applications/XcodeGr8.app/Contents/Info.plist DVTPlugInCompatibilityUUID</code></li>
</ul>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ul>
<li>1.生成了 XcodeGr8 之后，打不开。 解决方法：重启。</li>
<li>2.如果之前对其它版本的 Xcode-beat 也有使用这种方式，再对 Xcode8 GM 也是用该方式可能 MakeXcodeGr8Again 这个 APP 会一直闪退。 解决方法：卸载之前生成的 XcodeGr8，再重试。卸载后记得将开发路径重新指回原来的路径，即 sudo xcode-select -s /Applications/Xcode.app/Contents/Developer。如果这种方式还不行，卸载所有版本的 Xcode，然后再安装 GM 版，重复上述步骤。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>1.如果要卸载 XcodeGr8，记得将重新开发路径置回初始状态。</p>
<p>不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSURLProtocol 拦截网络请求]]></title>
      <url>jokewang.top/2016/09/01/NSURLProtocol%20%E6%8B%A6%E6%88%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>这篇文章是看来<a href="http://awhisper.github.io/" target="_blank" rel="external">敬哥</a>的<a href="https://github.com/Awhisper/VKDevTool" target="_blank" rel="external">黑盒测试库</a>想到的，这个测试库有个显示网络请求的模块，但是在自己项目里怎么也不行，上网查了各种资料总结了这篇文章。</p>
<h1 id="NSURLProtocol"><a href="#NSURLProtocol" class="headerlink" title="NSURLProtocol"></a>NSURLProtocol</h1><p>NSURLProtocol可以让我们拦截程序中的一切网络请求，主要进行如下拦截处理:</p>
<ul>
<li>自定义请求 和 响应</li>
<li>过滤掉某些请求不让其发起、以及修改</li>
<li>提供 自定义的全局缓存 逻辑</li>
<li>重定向 网络请求</li>
<li>提供 HTTP Mocking (方便前期测试)</li>
</ul>
<a id="more"></a>
<h1 id="如何拦截网络请求"><a href="#如何拦截网络请求" class="headerlink" title="如何拦截网络请求?"></a>如何拦截网络请求?</h1><h2 id="编写NSURLProtocol子类"><a href="#编写NSURLProtocol子类" class="headerlink" title="编写NSURLProtocol子类"></a>编写NSURLProtocol子类</h2><h3 id="重写方法一-请求的过滤，筛选出需要进行处理的请求"><a href="#重写方法一-请求的过滤，筛选出需要进行处理的请求" class="headerlink" title="重写方法一 请求的过滤，筛选出需要进行处理的请求"></a>重写方法一 请求的过滤，筛选出需要进行处理的请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">&#123;</div><div class="line"><span class="meta">#ifdef VKDevMode</span></div><div class="line">   </div><div class="line">    <span class="comment">//只处理http和https请求</span></div><div class="line">    <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</div><div class="line">    <span class="keyword">if</span> ( ([scheme caseInsensitiveCompare:<span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span> ||</div><div class="line">          [scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>))</div><div class="line">    &#123;</div><div class="line">            <span class="comment">//看看是否已经处理过了，防止无限循环</span></div><div class="line">         <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:VKURLProtocolHandledKey inRequest:request])</div><div class="line">           &#123;</div><div class="line">               <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">           &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法指明你是否要处理request，如果不打算处理的话返回NO就行，系统会使用默认的URL加载系统处理request，如果返回YES,URL Loading System会将request的处理操作交给你的urlProtocol。上面的代码我们只处理了http和https请求(你也可以拦截ftp等请求),通常我们的接口中都会包含特定的字符串，将它设置为你项目中对应的接口字段即可。还有一点需要注意，我们不能总是返回YES，这样会导致无限循环，(因为一个请求在被拦截处理过程中，也会发起一个请求) 我们可以通过+ (void)setProperty:(id)value forKey:(NSString <em>)key inRequest:(NSMutableURLRequest </em>)request方法来标记request已经被处理过，如果通过+ (nullable id)propertyForKey:(NSString <em>)key inRequest:(NSURLRequest </em>)request方法获取到已经处理过该request，则返回NO。</p>
<h3 id="重写方法二、请求重定向、修改请求头"><a href="#重写方法二、请求重定向、修改请求头" class="headerlink" title="重写方法二、请求重定向、修改请求头"></a>重写方法二、请求重定向、修改请求头</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSURLRequest</span> *) canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写方法三、让被拦截的请求执行"><a href="#重写方法三、让被拦截的请求执行" class="headerlink" title="重写方法三、让被拦截的请求执行"></a>重写方法三、让被拦截的请求执行</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)startLoading&#123;</div><div class="line">    <span class="comment">//打标签，防止无限循环</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [[<span class="keyword">self</span> request] mutableCopy];</div><div class="line">    </div><div class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey:VKURLProtocolHandledKey inRequest:mutableReqeust];</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">    <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableReqeust delegate:<span class="keyword">self</span>];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写方法四、取消执行请求"><a href="#重写方法四、取消执行请求" class="headerlink" title="重写方法四、取消执行请求"></a>重写方法四、取消执行请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)stopLoading&#123;</div><div class="line">    [<span class="keyword">self</span>.connection cancel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写方法五、可用来使用缓存数据结束此次网络请求"><a href="#重写方法五、可用来使用缓存数据结束此次网络请求" class="headerlink" title="重写方法五、可用来使用缓存数据结束此次网络请求"></a>重写方法五、可用来使用缓存数据结束此次网络请求</h3><p>如果不考虑自定义缓存逻辑，可以不重写此方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+(<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a toRequest:(<span class="built_in">NSURLRequest</span> *)b</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="demo1-自定义NSURLProtol拦截请求后进行处理，然后使用NSURLSession继续执行网络请求"><a href="#demo1-自定义NSURLProtol拦截请求后进行处理，然后使用NSURLSession继续执行网络请求" class="headerlink" title="demo1 自定义NSURLProtol拦截请求后进行处理，然后使用NSURLSession继续执行网络请求"></a>demo1 自定义NSURLProtol拦截请求后进行处理，然后使用NSURLSession继续执行网络请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MySessionURLProtocol</span> : <span class="title">NSURLProtocol</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"MySessionURLProtocol.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">//防止循环拦截的标识</span></div><div class="line"><span class="meta">#define protocolKey @<span class="meta-string">"SessionProtocolKey"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MySessionURLProtocol</span> ()&lt;<span class="title">NSURLSessionDataDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> * session;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MySessionURLProtocol</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  是否拦截处理指定的请求</div><div class="line"> *</div><div class="line"> *  @param request 指定的请求</div><div class="line"> *</div><div class="line"> *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     防止无限循环，因为一个请求在被拦截处理过程中，也会发起一个请求，这样又会走到这里，如果不进行处理，就会造成无限循环</div><div class="line">     如果已经拦截处理了，就不再进行拦截了，直接让其发起网络请求.</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:protocolKey inRequest:request]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// URL的全路径字符串</span></div><div class="line">    <span class="built_in">NSString</span> * url = request.URL.absoluteString;</div><div class="line">    </div><div class="line">  <span class="comment">//只处理http和https请求</span></div><div class="line">  <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</div><div class="line">  <span class="keyword">if</span> ( ([scheme caseInsensitiveCompare:<span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span> ||</div><div class="line">     [scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>))</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行</div><div class="line"> *</div><div class="line"> *  @param request 原请求</div><div class="line"> *</div><div class="line"> *  @return 修改后的请求</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 修改了请求的头部信息</span></div><div class="line">    <span class="built_in">NSMutableURLRequest</span> * mutableReq = [request mutableCopy];</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableDictionary</span> * headers = [mutableReq.allHTTPHeaderFields mutableCopy];</div><div class="line">    [headers setObject:<span class="string">@"BBBB"</span> forKey:<span class="string">@"Key2"</span>];</div><div class="line">    </div><div class="line">    mutableReq.allHTTPHeaderFields = headers;</div><div class="line">    </div><div class="line">    <span class="comment">//返回修改请求头后的Request</span></div><div class="line">    <span class="keyword">return</span> [mutableReq <span class="keyword">copy</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//还可以修改Request.url进行重定向</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  开始加载，在该方法中，加载一个请求</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)startLoading &#123;</div><div class="line"></div><div class="line">  </div><div class="line">    <span class="built_in">NSMutableURLRequest</span> * request = [<span class="keyword">self</span>.request mutableCopy];</div><div class="line">    </div><div class="line">    <span class="comment">// 标记当前传入的Request已经被拦截处理过，</span></div><div class="line">    <span class="comment">//防止在最开始又继续拦截处理</span></div><div class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@(<span class="literal">YES</span>) forKey:protocolKey inRequest:request];</div><div class="line">    </div><div class="line">    <span class="comment">//如下使用NSURLSession让拦截的请求进行请求网络</span></div><div class="line">    <span class="built_in">NSURLSessionConfiguration</span> * config = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:config delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> * task = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    [task resume];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  取消请求</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)stopLoading &#123;</div><div class="line">    [<span class="keyword">self</span>.session invalidateAndCancel];</div><div class="line">    <span class="keyword">self</span>.session = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSURLSessionDataDelegate</span></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">         dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line">completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span></div><div class="line">          didReceiveResponse:response</div><div class="line">          cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</div><div class="line">    </div><div class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">         dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">   didReceiveData:(<span class="built_in">NSData</span> *)data</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler</div><div class="line">&#123;</div><div class="line">    completionHandler(proposedResponse);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="demo2、简单的重定向处理"><a href="#demo2、简单的重定向处理" class="headerlink" title="demo2、简单的重定向处理"></a>demo2、简单的重定向处理</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MySessionURLProtocol</span></span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+ (<span class="built_in">NSURLRequest</span> *) canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</div><div class="line">    mutableReqeust = [<span class="keyword">self</span> redirectHostInRequset:mutableReqeust];</div><div class="line">    <span class="keyword">return</span> mutableReqeust;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">+(<span class="built_in">NSMutableURLRequest</span>*)redirectHostInRequset:(<span class="built_in">NSMutableURLRequest</span>*)request</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([request.URL host].length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//原始url全路径</span></div><div class="line">    <span class="built_in">NSString</span> *originUrlString = [request.URL absoluteString];</div><div class="line">    </div><div class="line">    <span class="comment">//原始url的host</span></div><div class="line">    <span class="built_in">NSString</span> *originHostString = [request.URL host];</div><div class="line">    </div><div class="line">    <span class="comment">//获取host的range</span></div><div class="line">    <span class="built_in">NSRange</span> hostRange = [originUrlString rangeOfString:originHostString];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (hostRange.location == <span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//重定向到bing搜索主页</span></div><div class="line">    <span class="built_in">NSString</span> *ip = <span class="string">@"cn.bing.com"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 替换开始的host</span></div><div class="line">    <span class="built_in">NSString</span> *urlString = [originUrlString stringByReplacingCharactersInRange:hostRange withString:ip];</div><div class="line">    </div><div class="line">    <span class="comment">//得到重定向后的url</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</div><div class="line">    </div><div class="line">    <span class="comment">//将新的url赋值给Request</span></div><div class="line">    request.URL = url;</div><div class="line"></div><div class="line">    <span class="comment">//返回修改host重定向的request</span></div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="demo3自定义NSURLProtol拦截请求后进行处理，然后使用NSURLConnection继续执行网络请求"><a href="#demo3自定义NSURLProtol拦截请求后进行处理，然后使用NSURLConnection继续执行网络请求" class="headerlink" title="demo3自定义NSURLProtol拦截请求后进行处理，然后使用NSURLConnection继续执行网络请求"></a>demo3自定义NSURLProtol拦截请求后进行处理，然后使用NSURLConnection继续执行网络请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"MyConnectionURLProtocol.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#define protocolKey @<span class="meta-string">"ConnectionProtocolKey"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyConnectionURLProtocol</span> () &lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLConnection</span> * connection;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyConnectionURLProtocol</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  是否拦截处理指定的请求</div><div class="line"> *</div><div class="line"> *  @param request 指定的请求</div><div class="line"> *</div><div class="line"> *  @return 返回YES表示要拦截处理，返回NO表示不拦截处理</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">/* </span></div><div class="line">        防止无限循环，因为一个请求在被拦截处理过程中，也会发起一个请求，这样又会走到这里，如果不进行处理，就会造成无限循环</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:protocolKey inRequest:request]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> * url = request.URL.absoluteString;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果url已http或https开头，则进行拦截处理，否则不处理</span></div><div class="line">    <span class="keyword">if</span> ([url hasPrefix:<span class="string">@"http"</span>] || [url hasPrefix:<span class="string">@"https"</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  如果需要对请求进行重定向，添加指定头部等操作，可以在该方法中进行</div><div class="line"> *</div><div class="line"> *  @param request 原请求</div><div class="line"> *</div><div class="line"> *  @return 修改后的请求</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 修改了请求的头部信息</span></div><div class="line">    <span class="built_in">NSMutableURLRequest</span> * mutableReq = [request mutableCopy];</div><div class="line">    <span class="built_in">NSMutableDictionary</span> * headers = [mutableReq.allHTTPHeaderFields mutableCopy];</div><div class="line">    [headers setObject:<span class="string">@"AAAA"</span> forKey:<span class="string">@"Key1"</span>];</div><div class="line">    mutableReq.allHTTPHeaderFields = headers;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"connection reset header"</span>);</div><div class="line">    <span class="keyword">return</span> [mutableReq <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  开始加载，在该方法中，加载一个请求</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)startLoading &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> * request = [<span class="keyword">self</span>.request mutableCopy];</div><div class="line">    <span class="comment">// 表示该请求已经被处理，防止无限循环</span></div><div class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@(<span class="literal">YES</span>) forKey:protocolKey inRequest:request];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  取消请求</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)stopLoading &#123;</div><div class="line">    [<span class="keyword">self</span>.connection cancel];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSURLConnectionDelegate</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didFailWithError:error];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="注册NSURLProtocol子类"><a href="#注册NSURLProtocol子类" class="headerlink" title="注册NSURLProtocol子类"></a>注册NSURLProtocol子类</h2><p>当app准备发起网络请求时会遍历所有已注册的NSURLProtocol，询问它们能否处理当前请求，所以你需要尽早注册这个Protocol。在遍历子类的过程是反向遍历的，最后注册的子类会先被遍历，这样自定义的子类将能提前截获请求，当一个子类截获请求后，将终止遍历。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions </div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSURLProtocol</span> registerClass:[MyURLProtocol <span class="keyword">class</span>]];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>NSURLProtocol 可以拦截 NSURLConnection、NSURLSession、UIwebview 的请求，但是不能拦截WKwebview 和CFNetwork的请求</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   <span class="built_in">NSError</span> *error =[<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"woshige erro"</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://appwk.baidu.com/naapi/iap/userbankinfo?uid=bd_0&amp;from=ios_appstore&amp;app_ua=Simulator&amp;ua=bd_1334_750_Simulator_3.4.9_9.2&amp;fr=2&amp;pid=1&amp;bid=2&amp;Bdi_bear=wifi&amp;app_ver=3.4.9&amp;sys_ver=9.2&amp;cuid=50c78ca9f3c39a34c963de578bef1d8c7aecc087&amp;sessid=1471498926&amp;screen=750_1334&amp;opid=wk_na&amp;ydvendor=84942C9A-E479-4856-945A-D55FBCDF4D57"</span>];</div><div class="line">    <span class="comment">// 通过URL初始化task,在block内部可以直接对返回的数据进行处理</span></div><div class="line">    <span class="built_in">NSURLSessionTask</span> *task = [session dataTaskWithURL:url</div><div class="line">                                    completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">                                        <span class="keyword">if</span> (data) &#123;</div><div class="line">                                            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;];</div><div class="line">    [task resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="AFNetworking-3-0-以后版本出现的问题"><a href="#AFNetworking-3-0-以后版本出现的问题" class="headerlink" title="AFNetworking 3.0 以后版本出现的问题"></a>AFNetworking 3.0 以后版本出现的问题</h1><p>NSURLProtocol 确实可以拦截NSURLSession的请求，但是敬哥DEMO中的NSURLSession 是这样创建的<br>      NSURLSession *session = [NSURLSession sharedSession];<br>这样创建的session会使用全局的cooike和其他设置，所以默认是会被hook掉。但是AFN并不是这样创建的session。所以默认是不起作用的。<br>解决办法一是<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line"><span class="built_in">NSArray</span> *protocolArray = @[[VKURLProtocol <span class="keyword">class</span>]];</div><div class="line">configuration.protocolClasses = protocolArray;</div><div class="line"></div><div class="line"></div><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:configuration];</div></pre></td></tr></table></figure></p>
<p>像这样在每个请求之前添加<code>protocolClasses</code>或者子类和AFN然后进行设置。</p>
<p>简单的办法是。修改AFN源文件<code>AFURLSessionManager</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</div><div class="line">....</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!configuration) &#123;</div><div class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">        <span class="built_in">NSArray</span> *protocolArray = @[<span class="built_in">NSClassFromString</span>(<span class="string">@"VKURLProtocol"</span>)];</div><div class="line">        configuration.protocolClasses = protocolArray;</div><div class="line">    &#125;</div><div class="line"> ....</div></pre></td></tr></table></figure></p>
<p>在这个if中对<code>NSURLSessionConfiguration</code>进行设置。或者采用method swizzing的方法进行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS事件响应链]]></title>
      <url>jokewang.top/2016/08/24/iOS%E5%93%8D%E5%BA%94%E9%93%BE/</url>
      <content type="html"><![CDATA[<h1 id="系统如何获取到了用户进行了“单击”这一行为？"><a href="#系统如何获取到了用户进行了“单击”这一行为？" class="headerlink" title="系统如何获取到了用户进行了“单击”这一行为？"></a>系统如何获取到了用户进行了“单击”这一行为？</h1><p>操作系统把包含这些点击事件的信息包装成UITouch和UIEvent形式的实例，然后找到当前运行的程序，逐级寻找能够响应这个事件的对象，直到没有响应者响应。这一寻找的过程，被称作事件的响应链，如下图所示，不用的响应者以链式的方式寻找</p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E5%93%8D%E5%BA%94%E9%93%BE.jpg" width="40%"><br><a id="more"></a> </p>
<h1 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h1><p>在iOS中，能够响应事件的对象都是UIResponder的子类对象。UIResponder提供了四个用户点击的回调方法，分别对应用户点击开始、移动、点击结束以及取消点击，其中只有在程序强制退出或者来电时，取消点击事件才会调用。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Generally, all responders which do custom touch handling should override all four of these methods.</span></div><div class="line"><span class="comment">// Your responder will receive either touchesEnded:withEvent: or touchesCancelled:withEvent: for each</span></div><div class="line"><span class="comment">// touch it is handling (those touches it received in touchesBegan:withEvent:).</span></div><div class="line"><span class="comment">// *** You must handle cancelled touches to ensure correct behavior in your application.  Failure to</span></div><div class="line"><span class="comment">// do so is very likely to lead to incorrect behavior or crashes.</span></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="keyword">nullable</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</div><div class="line">- (<span class="keyword">void</span>)touchesEstimatedPropertiesUpdated:(<span class="built_in">NSSet</span> * _Nonnull)touches <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_1);<span class="comment">//9.1之后加入的3D触摸事件。</span></div></pre></td></tr></table></figure></p>
<p>在自定义UIView为基类的控件时，我们可以重写这几个方法来进行点击回调。在回调中，我们可以看到方法接收两个参数，一个UITouch对象的集合，还有一个UIEvent对象。这两个参数分别代表的是点击对象和事件对象。</p>
<ul>
<li>事件对象<br>iOS使用UIEvent表示用户交互的事件对象，在UIEvent.h文件中，我们可以看到有一个UIEventType类型的属性，这个属性表示了当前的响应事件类型。分别有多点触控、摇一摇以及远程操作（在iOS9之后新增了3DTouch事件类型）。在一个用户点击事件处理过程中，UIEvent对象是唯一的</li>
<li>点击对象<br>UITouch表示单个点击，其类文件中存在枚举类型UITouchPhase的属性，用来表示当前点击的状态。这些状态包括点击开始、移动、停止不动、结束和取消五个状态。每次点击发生的时候，点击对象都放在一个集合中传入UIResponder的回调方法中，我们通过集合中对象获取用户点击的位置。其中通过<code>- (CGPoint)locationInView:(nullable UIView *)view</code>获取当前点击坐标点，<code>- (CGPoint)previousLocationInView:(nullable UIView *)view</code>获取上个点击位置的坐标点。<br>为了确认UIView确实是通过UIResponder的点击方法响应点击事件的，我创建了UIView的类别，并重写+ (void)load方法，使用method_swizzling的方式交换点击事件的实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">    Method origin = class_getInstanceMethod([<span class="built_in">UIView</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(touchesBegan:withEvent:));</div><div class="line">    Method custom = class_getInstanceMethod([<span class="built_in">UIView</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lxd_touchesBegan:withEvent:));</div><div class="line">    method_exchangeImplementations(origin, custom);</div><div class="line"></div><div class="line">    origin = class_getInstanceMethod([<span class="built_in">UIView</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(touchesMoved:withEvent:));</div><div class="line">    custom = class_getInstanceMethod([<span class="built_in">UIView</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lxd_touchesMoved:withEvent:));</div><div class="line">    method_exchangeImplementations(origin, custom);</div><div class="line"></div><div class="line">    origin = class_getInstanceMethod([<span class="built_in">UIView</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(touchesEnded:withEvent:));</div><div class="line">    custom = class_getInstanceMethod([<span class="built_in">UIView</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lxd_touchesEnded:withEvent:));</div><div class="line">    method_exchangeImplementations(origin, custom);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)lxd_touchesBegan: (<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent: (<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ --- begin"</span>, <span class="keyword">self</span>.class);</div><div class="line">    [<span class="keyword">self</span> lxd_touchesBegan: touches withEvent: event];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)lxd_touchesMoved: (<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent: (<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ --- move"</span>, <span class="keyword">self</span>.class);</div><div class="line">    [<span class="keyword">self</span> lxd_touchesMoved: touches withEvent: event];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)lxd_touchesEnded: (<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent: (<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ --- end"</span>, <span class="keyword">self</span>.class);</div><div class="line">    [<span class="keyword">self</span> lxd_touchesEnded: touches withEvent: event];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在新建的项目中，我分别创建了AView、BView、CView和DView四个UIView的子类，然后点击任意一个位置：</p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E5%93%8D%E5%BA%94%E9%93%BE_2.jpeg" width="40%"></p>
<p>在我点击上图绿色视图的时候，控制台输出了下面的日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CView --- begin</div><div class="line">CView --- end</div></pre></td></tr></table></figure></p>
<p>由此可见在我们点击UIView的时候，是通过touches相关的点击事件进行回调处理的。</p>
<p>除了touches回调的几个点击事件，手势UIGestureRecognizer对象也可以附加在view上，来实现其他丰富的手势事件。在view添加单击手势之后，原来的touchesEnded方法就无效了。最开始我一直认为view添加手势之后，原有的touches系列方法全部无效。但是在测试demo中，发现view添加手势之后，touchesBegan方法是有进行回调的，但是moved跟ended就没有进行回调。因此，在系统的touches事件处理中，在touchesBegan之后，应该是存在着一个调度后续事件（nextHandler）处理的方法，个人猜测事件调度的处理大致如下图示：</p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E5%93%8D%E5%BA%94%E9%93%BE_3.jpeg" width="40%"></p>
<h1 id="响应链传递"><a href="#响应链传递" class="headerlink" title="响应链传递"></a>响应链传递</h1><p>上面已经介绍了某个控件在接收到点击事件时的处理，那么系统是怎么通过用户点击的位置找到处理点击事件的view的呢？<br>在上文我们已经说过了系统通过不断查找下一个响应者来响应点击事件，而所有的可交互控件都是UIResponder直接或者间接的子类，那么我们是否可以在这个类的头文件中找到关键的属性呢？</p>
<p>正好存在着这么一个方法：<code>- (nullable UIResponder *)nextResponder</code>，通过方法名我们不难发现这是获取当前view的下一个响应者，那么我们重写touchesBegan方法，逐级获取下一响应者，直到没有下一个响应者位置。相关代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIResponder</span> * next = [<span class="keyword">self</span> nextResponder];</div><div class="line">    <span class="built_in">NSMutableString</span> * prefix = <span class="string">@""</span>.mutableCopy;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (next != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@%@"</span>, prefix, [next <span class="keyword">class</span>]);</div><div class="line">        [prefix appendString: <span class="string">@"--"</span>];</div><div class="line">        next = [next nextResponder];</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>控制台输出的所有下级事件响应者如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AView</div><div class="line">--UIView</div><div class="line">----ViewController</div><div class="line">------UIWindow</div><div class="line">--------UIApplication</div><div class="line">----------AppDelegate</div></pre></td></tr></table></figure></p>
<p>虽然结果非常有层次，但是从系统逐级查找响应者的角度上来说，这个输出的顺序是刚好相反的。为什么会出现这种问题呢？我们可以看到输出中存在一个ViewController类，说明UIViewController也是UIResponder的子类。但是我们可以发现，controller是一个view的管理者，即便它是响应链的成员之一，但是按照逻辑来说，控制器不应该是系统查找对象之一，通过nextResponder方法查找的这个思路是不正确的。<br>后来，发现在UIView的头文件中存在这么两个方法，分别返回UIView和BOOL类型的方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;   <span class="comment">// recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system</span></div><div class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;   <span class="comment">// default returns YES if point is in bounds</span></div></pre></td></tr></table></figure></p>
<p>根据方法名，一个是根据点击坐标返回事件是否发生在本视图以内，另一个方法是返回响应点击事件的对象。通过这两个方法，我们可以猜到，系统在收到点击事件的时候通过不断遍历当前视图上的子视图的这些方法，获取下一个响应的视图。因此，继续通过method_swizzling方式修改这两个方法的实现，并且测试输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">UIStatusBarWindow can answer 1</div><div class="line">UIStatusBar can answer 0</div><div class="line">UIStatusBarForegroundView can answer 0</div><div class="line">UIStatusBarServiceItemView can answer 0</div><div class="line">UIStatusBarDataNetworkItemView can answer 0</div><div class="line">UIStatusBarBatteryItemView can answer 0</div><div class="line">UIStatusBarTimeItemView can answer 0</div><div class="line">hit view: UIStatusBar</div><div class="line">hit view: UIStatusBarWindow</div><div class="line">UIWindow can answer 1</div><div class="line">UIView can answer 1</div><div class="line">hit view: _UILayoutGuide</div><div class="line">hit view: _UILayoutGuide</div><div class="line">AView can answer 1</div><div class="line">DView can answer 0</div><div class="line">hit view: DView</div><div class="line">BView can answer 0</div><div class="line">hit view: BView</div><div class="line">hit view: AView</div><div class="line">hit view: UIView</div><div class="line">hit view: UIWindow</div><div class="line">......  //下面是touches方法的输出</div></pre></td></tr></table></figure>
<p>最上面的UIStatusBar开头的类型大家可能没见过，但是不妨碍我们猜到这是状态栏相关的一些视图，具体可以查找苹果的文档中心（Xcode中快捷键shift+command+0打开）。从输出中不难看出系统先调用<code>pointInSide: WithEvent:</code>判断当前视图以及这些视图的子视图是否能接收这次点击事件，然后在调用<code>hitTest: withEvent:</code>依次获取处理这个事件的所有视图对象，在获取所有的可处理事件对象后，开始调用这些对象的touches回调方法</p>
<p>通过输出的方法调用，我们可以看到响应查找的顺序是： UIStatusBar相关的视图 -&gt; UIWindow -&gt; UIView -&gt; AView -&gt; DView -&gt; BView（系统在事件链传递的过程中一定会遍历所有的子视图判断是否能够响应点击事件），以本文demo为例，我们可以得出事件响应链查找的图示如下：</p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E5%93%8D%E5%BA%94%E9%93%BE_4.jpeg" width="40%"></p>
<p>那么在上面的查找响应者流程完成之后，系统会将本次事件中的点击转换成UITouch对象，然后将这些对象和UIEvent类型的事件对象传递给touchesBegan方法<br>不仅如此，从上面输出的nextResponder来看，所有的响应者都是在查找中返回可响应点击的视图。因此，我们可以推测出UIApplication对象维护着自己的一个响应者栈，当<code>pointInSide: withEvent:</code>返回yes的时候，响应者入栈。</p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E5%93%8D%E5%BA%94%E9%93%BE_5.jpeg" width="40%"></p>
<p>栈顶的响应者作为最优先处理事件的对象，假设AView不处理事件，那么出栈，移交给UIView，以此下去，直到事件得到了处理或者到达AppDelegate后依旧未响应，事件被摒弃为止。通过这个机制我们也可以看到controller是响应者栈中的例外，即便没有<code>pointInSide: withEvent:</code>的方法返回可响应，controller依旧能够入栈成为UIView的下一个响应者。</p>
<h1 id="响应链应用"><a href="#响应链应用" class="headerlink" title="响应链应用"></a>响应链应用</h1><p>既然已经知道了系统是怎么获取响应视图的流程了，那么我们可以通过重写查找事件处理者的方法来实现不规则形状点击。最常见的不规则视图就是圆形视图，在demo中我设置view的宽高为200，那么重写方法事件如下:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="built_in">CGFloat</span> halfWidth = <span class="number">100</span>;</div><div class="line">    <span class="built_in">CGFloat</span> xOffset = point.x - <span class="number">100</span>;</div><div class="line">    <span class="built_in">CGFloat</span> yOffset = point.y - <span class="number">100</span>;</div><div class="line">    <span class="built_in">CGFloat</span> radius = sqrt(xOffset * xOffset + yOffset * yOffset);</div><div class="line">    <span class="keyword">return</span> radius &lt;= halfWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/blog_%E5%93%8D%E5%BA%94%E9%93%BE_6.gif" width="40%"></p>
<p>根据view找到对应的controller:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">UIViewController</span>* <span class="built_in">UIViewParentController</span>(<span class="built_in">UIView</span> *view)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="built_in">UIResponder</span> *responder=view;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> ([responder isKindOfClass:[<span class="built_in">UIView</span> <span class="keyword">class</span>]])</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        responder=[responder nextResponder];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime模型到模型赋值]]></title>
      <url>jokewang.top/2016/08/24/runtime%E6%A8%A1%E5%9E%8B%E5%88%B0%E6%A8%A1%E5%9E%8B%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<p>需求：两个同样的界面，同样的功能，只因为是不一个入口，接口不一样。接口不一样就算了，接口下来的JSON的key都不一样。我又懒的手动赋值。后来发现这样一个方法</p>
<a id="more"></a> 
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">-(talkuser*)changeModle:(<span class="keyword">id</span>)model</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">objc_property_t *properties=class_copyPropertyList([model <span class="keyword">class</span>], &amp;count);<span class="comment">//获取传进来模型的Property列表</span></div><div class="line"></div><div class="line">talkuser *backModel=[[talkuser alloc]init];<span class="comment">//创建目标模型</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line"></div><div class="line">objc_property_t property = properties[i];<span class="comment">//从Property列表中取Property属性</span></div><div class="line"></div><div class="line"><span class="comment">//获取属性的名称C语言字符串</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cName =property_getName(property);</div><div class="line"></div><div class="line"><span class="comment">//转换为Objective C字符串</span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithCString:cName encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"></div><div class="line"><span class="keyword">id</span> value= [model valueForKey:name];</div><div class="line"></div><div class="line">[backModel setValue:value forKey:name];<span class="comment">//赋值</span></div><div class="line"></div><div class="line">&#125;</div><div class="line">free(propertys);<span class="comment">//用完释放掉列表,按住option+左键看class_copyPropertyList方法会提示</span></div><div class="line">returnbackModel;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[科目一考试通过]]></title>
      <url>jokewang.top/2016/08/08/%E7%A7%91%E7%9B%AE%E4%B8%80%E8%80%83%E8%AF%95%E9%80%9A%E8%BF%87/</url>
      <content type="html"><![CDATA[<p>前几个月看<a href="http://awhisper.github.io/2016/07/10/CarInMyLife/" target="_blank" rel="external">味精</a>大神买车的文章，激起了我买车的欲望。于是报名，看车。<br>车已经选好了 <strong>速腾1.4T自动豪华版</strong> 本来想买1.6最便宜的自动款，去4S店看了看，差好多啊。。。加钱！（打肿脸充胖子）。关键就是驾照了。</p>
<p>7.27报名，今天科目一过了。恩，还算可以。考了满分！！！   希望能尽快进行科目二。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[scrollview滚动结束的监听]]></title>
      <url>jokewang.top/2016/07/28/scrollView%E7%9B%91%E5%90%AC%E6%BB%9A%E5%8A%A8%E7%BB%93%E6%9D%9F/</url>
      <content type="html"><![CDATA[<p>在iOS中使用UITableView的时候，有时候需要检测UITableView的滚动动画是否结束，iOS没有直接提供这样的API。 先看一下现有的几个方法是怎样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate;</div></pre></td></tr></table></figure></p>
<p>这个方法表示手指离开了scrollview，第二个参数用于判断滚动速度是否慢慢下降。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView;      <span class="comment">// called when scroll view grinds to a halt</span></div></pre></td></tr></table></figure>
<p>这个方法看上去挺像我们要找的：停止减速。但是，从注释看，“嘎然而止”的时候才会被调用，很明显，我们要的是“自然停止”时被调的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView; <span class="comment">// called when setContentOffset scrollRectVisible:animated: finishes. not called if not animating</span></div></pre></td></tr></table></figure>
<p>这个是指scrollview停止滚动动画，嗯，这下是我们想要的了吧！</p>
<p>抱歉，不是！！！ 试验一下就会发现，无论怎么滚动怎么停止，这个方法都不会被调！处分用代码的方式调用了setContentOffset scrollRectVisible:animated: finishes，但是，我们手指触发试图滚动是不会调该方法的……<br><a id="more"></a> </p>
<p>###解决方法<br>我们自己主动去调scrollViewDidEndScrollingAnimation。</p>
<p>原理：在- (void)scrollViewDidScroll:(UIScrollView *)scrollView内，创建一个异步调用，等待0.1秒后调scrollViewDidEndScrollingAnimation。由于scrollViewDidScroll会不断被调用，再次触发时取消上一次的异步请求。等到不再滚动时，最后一次的请求不会被取消，最终会跑到scrollViewDidScroll，然后，添加想要在滚动停止时调用的代码即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)sender</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>];</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(scrollViewDidEndScrollingAnimation:) withObject:<span class="literal">nil</span> afterDelay:<span class="built_in">CGFLOAT_MIN</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span>];</div><div class="line">    <span class="comment">//这里添加你的逻辑，比如，触发上拉加载更多</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blog.lessfun.com/blog/2013/12/06/detect-uiscrollview-did-end-scrolling-animate/" target="_blank" rel="external">参考链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RSA加密]]></title>
      <url>jokewang.top/2016/07/22/RSA%E5%8A%A0%E5%AF%86/</url>
      <content type="html"><![CDATA[<p>很长时间搞不清楚RSA到底是用公钥加密还是私钥加密，看了一些文章发现是下面这样：</p>
<blockquote>
<p>公钥加密私钥解密是密送，保证消息即使公开也只有私钥持有者能读懂。<br>私钥加密公钥解密是签名，保证消息来源是私钥持有者。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[真·情怀]]></title>
      <url>jokewang.top/2016/07/22/%E7%BD%91%E6%98%93%E4%BA%92%E8%81%94%E7%BD%91%E6%8B%9B%E8%81%98%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>只能说网易的棋下的不错，中国最良心的互联网企业。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=421885610&auto=0&height=66"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[红花ノ乙女呗]]></title>
      <url>jokewang.top/2016/07/13/%E7%BA%A2%E8%8A%B1%E3%83%8E%E4%B9%99%E5%A5%B3%E5%91%97/</url>
      <content type="html"><![CDATA[<p>吾是花儿么？是蝶抑或是鬼？</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=4929317&auto=0&height=66"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[点击statusBar滚回最顶部]]></title>
      <url>jokewang.top/2016/07/06/%E7%82%B9%E5%87%BBstatusBar%E6%BB%9A%E5%9B%9E%E6%9C%80%E9%A1%B6%E9%83%A8/</url>
      <content type="html"><![CDATA[<p>  iOS系统的statusBar自带滚回最顶部。就算在statusBar位置添加个view也是可以的。<br>但是，这些只在当前controller只有一个scrollview的时候才起作用。如果有多个scrollview，系统当时就懵逼了。<br>解决办法：<br>      1、每个页面中不需要滚动的scrollview 设置 scrollsToTop=No;只留下需要滚动回顶部的，但是，懒癌晚期的我怎么会这样做。<br>      2、<a href="http://stackoverflow.com/questions/3753097/how-to-detect-touches-in-status-bar" target="_blank" rel="external">statck overflow</a>上有个答案提供了一个方法</p>
<blockquote>
<p>在AppDelegate.m 中</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kStatusBarTappedNotification = <span class="string">@"statusBarTappedNotification"</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</div><div class="line">    <span class="built_in">CGPoint</span> location = [[[event allTouches] anyObject] locationInView:[<span class="keyword">self</span> window]];</div><div class="line">    <span class="built_in">CGRect</span> statusBarFrame = [<span class="built_in">UIApplication</span> sharedApplication].statusBarFrame;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(statusBarFrame, location)) &#123;</div><div class="line">        [<span class="keyword">self</span> statusBarTouchedAction];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)statusBarTouchedAction &#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:kStatusBarTappedNotification</div><div class="line">                                                        object:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a> 
<blockquote>
<p>然后在viewWillAppear中</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                         selector:<span class="keyword">@selector</span>(clickStatusBar)             </div><div class="line">                                             name:kStatusBarTappedNotification</div><div class="line">                                           object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>viewDidDisappear中</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:kStatusBarTappedNotification object:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>通知方法clickStatusBar</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)clickStatusBar</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UITableViewController</span> <span class="keyword">class</span>]])</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">UITableViewController</span>* tvc=(<span class="built_in">UITableViewController</span>*)<span class="keyword">self</span>;</div><div class="line">        [tvc.tableView scrollRectToVisible:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>) animated:<span class="literal">YES</span>];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span>.view.subviews)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">UITableView</span> <span class="keyword">class</span>]])</div><div class="line">        &#123;</div><div class="line">             [obj scrollRectToVisible:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>) animated:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  前面说过，我是懒癌晚期啊。每个页面加能累死我。 所以，新建一个UIViewController的类别然后重写+load方法，最后利用Method swizzing Hook掉viewWillAppear和viewDidDisappear方法即可。<br>  关于如何使用Method swizzing 可以参考<a href="https://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/" target="_blank" rel="external">这篇文章</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何开源许可证]]></title>
      <url>jokewang.top/2016/07/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/</url>
      <content type="html"><![CDATA[<p>一个简单的参考</p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/3e5cb4629d991c4b826788fe3e2877e5_r.jpg"></p>
<p>详细可以参考<a href="https://www.zhihu.com/question/28292322" target="_blank" rel="external">这里</a>的回答</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[享受孤独]]></title>
      <url>jokewang.top/2016/07/06/%E4%BA%AB%E5%8F%97%E5%AD%A4%E7%8B%AC/</url>
      <content type="html"><![CDATA[<p>总在合群，偶尔享受孤独 (其实就是，这首歌真的很好听)</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=27937279&auto=0&height=66"></iframe>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSArray排序方法]]></title>
      <url>jokewang.top/2016/07/05/%E6%A8%A1%E5%9E%8B%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>系统API：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- sortedArrayUsingFunction:context:    </div><div class="line">– sortedArrayUsingFunction:context:hint:</div><div class="line">– sortedArrayUsingDescriptors:  </div><div class="line">– sortedArrayUsingSelector:  </div><div class="line">- sortedArrayUsingComparator:   </div><div class="line">- sortedArrayWithOptions:usingComparator:</div></pre></td></tr></table></figure>
<p>以上方法可以分为四类,Function,Descriptor,Selector,Comparator,最简单易用的应该是Comparator,用一个Block非常方便的解决大多数排序,强烈推荐,其他方法稍微麻烦一些。</p>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h2 id="sortedArrayUsingFunction-context"><a href="#sortedArrayUsingFunction-context" class="headerlink" title="- sortedArrayUsingFunction:context:"></a>- sortedArrayUsingFunction:context:</h2><p>首先,自己按照参数要求写排序方法,如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSInteger</span> intSort(<span class="keyword">id</span> num1, <span class="keyword">id</span> num2, <span class="keyword">void</span> *context) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> v1 = [num1 intValue];</div><div class="line">    <span class="keyword">int</span> v2 = [num2 intValue];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (v1 &lt; v2) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">NSOrderedAscending</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 &gt; v2) &#123;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="built_in">NSOrderedDescending</span>;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">NSOrderedSame</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a> 
<p>然后调用即可</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *numberArray = @[@<span class="number">2</span>, @<span class="number">4</span>, @<span class="number">12</span>, @<span class="number">1</span>, @<span class="number">9</span>];  </div><div class="line"><span class="built_in">NSArray</span> *funcitonSortedArray = [numberArray sortedArrayUsingFunction:intSort context:<span class="literal">NULL</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@" funcitonSortedArray = %@"</span>,funcitonSortedArray);</div></pre></td></tr></table></figure>
<h2 id="–-sortedArrayUsingFunction-context-hint"><a href="#–-sortedArrayUsingFunction-context-hint" class="headerlink" title="– sortedArrayUsingFunction:context:hint:"></a>– sortedArrayUsingFunction:context:hint:</h2><p>假设你有一个经常要排序的大数组,即使轻微的改变(比如添加或删除一个元素),也需要重新对数组排序,这样排序成本很高.这时,我们就可以用此方法.</p>
<p>首先,[anArray sortedArrayHint],此方法应该被已排序好的数组调用,来获得一个私有的data来加速轻微改变的数组的排序.</p>
<p>下面是简单用法,由于数组不够大,所以,体现不出此方法的优势.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSInteger</span> alphabeticSort(<span class="keyword">id</span> string1, <span class="keyword">id</span> string2, <span class="keyword">void</span> *reverse)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (*(<span class="built_in">BOOL</span> *)reverse == <span class="literal">YES</span>) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> [string2 localizedCaseInsensitiveCompare:string1];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [string1 localizedCaseInsensitiveCompare:string2];</div><div class="line">&#125;  </div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)hintFunctionDemo &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSMutableArray</span> *anArray =</div><div class="line">    [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"aa"</span>, <span class="string">@"ab"</span>, <span class="string">@"ac"</span>, <span class="string">@"ad"</span>, <span class="string">@"ae"</span>, <span class="string">@"af"</span>, <span class="string">@"ag"</span>,</div><div class="line">     <span class="string">@"ah"</span>, <span class="string">@"ai"</span>, <span class="string">@"aj"</span>, <span class="string">@"ak"</span>, <span class="string">@"al"</span>, <span class="string">@"am"</span>, <span class="string">@"an"</span>, <span class="string">@"ao"</span>, <span class="string">@"ap"</span>, <span class="string">@"aq"</span>, <span class="string">@"ar"</span>, <span class="string">@"as"</span>, <span class="string">@"at"</span>,</div><div class="line">     <span class="string">@"au"</span>, <span class="string">@"av"</span>, <span class="string">@"aw"</span>, <span class="string">@"ax"</span>, <span class="string">@"ay"</span>, <span class="string">@"az"</span>, <span class="string">@"ba"</span>, <span class="string">@"bb"</span>, <span class="string">@"bc"</span>, <span class="string">@"bd"</span>, <span class="string">@"bf"</span>, <span class="string">@"bg"</span>, <span class="string">@"bh"</span>,</div><div class="line">     <span class="string">@"bi"</span>, <span class="string">@"bj"</span>, <span class="string">@"bk"</span>, <span class="string">@"bl"</span>, <span class="string">@"bm"</span>, <span class="string">@"bn"</span>, <span class="string">@"bo"</span>, <span class="string">@"bp"</span>, <span class="string">@"bq"</span>, <span class="string">@"br"</span>, <span class="string">@"bs"</span>, <span class="string">@"bt"</span>, <span class="string">@"bu"</span>,</div><div class="line">     <span class="string">@"bv"</span>, <span class="string">@"bw"</span>, <span class="string">@"bx"</span>, <span class="string">@"by"</span>, <span class="string">@"bz"</span>, <span class="string">@"ca"</span>, <span class="string">@"cb"</span>, <span class="string">@"cc"</span>, <span class="string">@"cd"</span>, <span class="string">@"ce"</span>, <span class="string">@"cf"</span>, <span class="string">@"cg"</span>, <span class="string">@"ch"</span>,</div><div class="line">     <span class="string">@"ci"</span>, <span class="string">@"cj"</span>, <span class="string">@"ck"</span>, <span class="string">@"cl"</span>, <span class="string">@"cm"</span>, <span class="string">@"cn"</span>, <span class="string">@"co"</span>, <span class="string">@"cp"</span>, <span class="string">@"cq"</span>, <span class="string">@"cr"</span>, <span class="string">@"cs"</span>, <span class="string">@"ct"</span>, <span class="string">@"cu"</span>,</div><div class="line">     <span class="string">@"cv"</span>, <span class="string">@"cw"</span>, <span class="string">@"cx"</span>, <span class="string">@"cy"</span>, <span class="string">@"cz"</span>, <span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// note: anArray is sorted</span></div><div class="line">    <span class="built_in">NSData</span> *sortedArrayHint = [anArray sortedArrayHint];</div><div class="line"></div><div class="line">    [anArray insertObject:<span class="string">@"be"</span> atIndex:<span class="number">5</span>];</div><div class="line"></div><div class="line">    <span class="comment">// sort with a hint</span></div><div class="line">    <span class="built_in">BOOL</span> reverseSort = <span class="literal">NO</span>;</div><div class="line">    <span class="built_in">NSArray</span> *sortedArray = [anArray sortedArrayUsingFunction:alphabeticSort</div><div class="line">                                                     context:&amp;reverseSort</div><div class="line">                                                        hint:sortedArrayHint];</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hintFunctionSortedArray = %@"</span>,sortedArray);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><blockquote>
<p>NSString,NSNumber都有和排序相关的方法,如NSString有:</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string;</div><div class="line"> - (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options:(<span class="built_in">NSStringCompareOptions</span>)mask;</div><div class="line"> - (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)compareRange;</div><div class="line"> - (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)compareRange locale:(<span class="keyword">nullable</span> <span class="keyword">id</span>)locale;</div><div class="line"> - (<span class="built_in">NSComparisonResult</span>)caseInsensitiveCompare:(<span class="built_in">NSString</span> *)string;</div><div class="line"> - (<span class="built_in">NSComparisonResult</span>)localizedCompare:(<span class="built_in">NSString</span> *)string;</div><div class="line"> - (<span class="built_in">NSComparisonResult</span>)localizedCaseInsensitiveCompare:(<span class="built_in">NSString</span> *)string;</div></pre></td></tr></table></figure>
<p> 我们可以直接利用这些方法来排序<br> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">NSArray</span> *alphabeticArray  = @[<span class="string">@"b"</span>, <span class="string">@"a"</span>, <span class="string">@"x"</span>, <span class="string">@"o"</span>, <span class="string">@"g"</span>, <span class="string">@"o"</span>];   </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,selectorSortedArray);</div></pre></td></tr></table></figure></p>
<h1 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a>Descriptor</h1><blockquote>
<p>用NSSortDescriptor,它是一个获取keyPath的工具,它能根据keyPath进行排序</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *modelArray = @[[Model name:<span class="string">@"LiuDaShuai"</span>  age:@<span class="number">26</span> height:@<span class="number">171</span>],</div><div class="line">                        [Model name:<span class="string">@"XiaoQiu"</span>     age:@<span class="number">27</span> height:@<span class="number">170</span>],</div><div class="line">                        [Model name:<span class="string">@"HaoQuShi"</span>    age:@<span class="number">28</span> height:@<span class="number">172</span>],</div><div class="line">                        [Model name:<span class="string">@"JunGang"</span>     age:@<span class="number">24</span> height:@<span class="number">171</span>],</div><div class="line">                        [Model name:<span class="string">@"KongMing"</span>    age:@<span class="number">30</span> height:@<span class="number">175</span>],</div><div class="line">                        [Model name:<span class="string">@"GaoFuShuai"</span>  age:@<span class="number">22</span> height:@<span class="number">180</span>]];  </div><div class="line"></div><div class="line"><span class="built_in">NSSortDescriptor</span> *sortDescriptor        = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@"m_age"</span> ascending:<span class="literal">YES</span>];</div><div class="line">    <span class="built_in">NSArray</span>          *sortDescriptors       = [<span class="built_in">NSArray</span> arrayWithObject:sortDescriptor];</div><div class="line">    <span class="built_in">NSArray</span>          *descriptorSortedArray = [modelArray sortedArrayUsingDescriptors:sortDescriptors];   </div><div class="line"></div><div class="line">[descriptorSortedArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        Model *tmp = obj;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"descriptorSortedArray model = %@"</span>, tmp.m_name);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>打印信息:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">descriptorSortedArray model = GaoFuShuai</div><div class="line">descriptorSortedArray model = JunGang</div><div class="line">descriptorSortedArray model = LiuDaShuai</div><div class="line">descriptorSortedArray model = XiaoQiu</div><div class="line">descriptorSortedArray model = HaoQuShi</div><div class="line">descriptorSortedArray model = KongMing</div></pre></td></tr></table></figure></p>
<h1 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h1><blockquote>
<p>最简单易用,强烈推荐</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSArray *modelArray = @[[Model name:@&quot;LiuDaShuai&quot;  age:@26 height:@171],</div><div class="line">                        [Model name:@&quot;XiaoQiu&quot;     age:@27 height:@170],</div><div class="line">                        [Model name:@&quot;HaoQuShi&quot;    age:@28 height:@172],</div><div class="line">                        [Model name:@&quot;JunGang&quot;     age:@24 height:@171],</div><div class="line">                        [Model name:@&quot;KongMing&quot;    age:@30 height:@175],</div><div class="line">                        [Model name:@&quot;GaoFuShuai&quot;  age:@22 height:@180]];   </div><div class="line"></div><div class="line">NSArray *comparatorSortedArray = [modelArray sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &#123;</div><div class="line"></div><div class="line">        Model *model1 = obj1;</div><div class="line">        Model *model2 = obj2;</div><div class="line"></div><div class="line">        return [model1.m_name compare:model2.m_name];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // 打印排序信息</div><div class="line">    [comparatorSortedArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">        Model *tmp = obj;</div><div class="line">        NSLog(@&quot;comparatorSortedArray model = %@&quot;, tmp.m_name);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第一篇博客]]></title>
      <url>jokewang.top/2016/07/05/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>弄了一下午+一晚上总算弄好了（好蠢。。），弄博客的过程中也学到了一些东西，比如RSS（虽然没用）， 比如MarkDown 总之感觉还是蛮有乐趣的。</p>
<p><img src="http://7xvz3k.com1.z0.glb.clouddn.com/raw_1427104383-min.jpeg" width="300" height="532.5"></p>
]]></content>
    </entry>
    
  
  
</search>
